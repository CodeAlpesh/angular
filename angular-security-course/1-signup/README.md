## Angular Security MasterClass - Web Security Fundamentals Course

### Inital client / server impl:

#### TODOs:
* signup & store password [securely??]
* signin & return basic user details
* handle error if any
* Change menu's as per user state

#### Auth Service
* communicate with remote using http
* will contain user's data/state
* will have default state anonymous
    * Setup Observable for user
    * Will you consume user$ Observable directly in views or will you derive some other Observables? Why? Will simplify UI code. No need to repeate checking of observable and its properties. 
* Can Create User model (interface)


#### TIPS:

> While passing JSON payload, You can use shorthand. Key name will be same as var name.
```
return this.http.post<User>('/api/signup', {email, password})
```

> Convert any truthy variable into boolean. Apply double bang
```
!!user.id
```

> suffix $ for observable type variables.

> To prevent access to the "observer-side" of a Subject.
Why? Subject can work as observer also. Add subscribers and itself will subscribe to other observable - multicasting.

```
loggedInuser: Subject<User> = new BehaviorSubject(ANONYMOUS_USER);
user$: Observable<User> = this.loggedInuser.asObservable();
```

> Can have derived Observabled. (function chain)
```   
loggedInuser: Subject<User> = new BehaviorSubject(ANONYMOUS_USER);
user$: Observable<User> = this.loggedInuser.asObservable();
isLoggedIn$: Observable<boolean> = this.user$.pipe(map( user => !!user.id));
isLoggedOut$: Observable<boolean> = this.isLoggedIn$.pipe(map( loggedIn => !loggedIn));
```

> How to update value for above Observers? 
* Use shareReplay operator to ensure request is sent just once. 
* Use tap operator to read value in observer chain and call next() on subject.
```
return this.http.post<User>('/api/signup', {email, password})
.pipe(
    shareReplay(),
    tap((user) => {
    this.loggedInuser.next(user);
    })
)
```

> Define type of map {keytype : value type}
```
const USERS: {[key: number]: DbUser} = {};
```

### Cryptographic hash function
Take a string of any length as input and produce a fixed-length hash value.

#### Sample hashing with Node.js
```
var crypto = require('crypto');
var password = 'monkey';
// we will use another hash other SHA-256 during the course, this is just for demo purposes
var hash = crypto.createHash('sha256').update(password).digest('hex');
console.log(hash);
// You should see in the console 000c285457fc971f862a79b786476c78812c8897063c6fa9c045f579a3b2d63f
```

#### Observations:
* Its not encryption. Ireversible. One way hashing.
* Same input generates same hash. Repeatable.
* Small change in input, completely different hash.
* hash(Single char) ... should not be able to guess position in hash(message) ... Progressive estimation attack.
* Very low probability of password collosion. hash(m1) == hash(m2)
* Hashes based storage are prone to dictionary attack. If db is compromised, attacker can compare to pre-calculated hashes.
	* What is the solution? 
        * Hash multiple times time ... 1000 to 10000 times.
        * Unique cryptographic Salt per user... hash(password + salt)
            * Possible have salt for each user and *MUST* store salt along with user details.
        * Password Based Key Derivation Functions ... https://en.wikipedia.org/wiki/PBKDF2
        ```
          DK = PBKDF2(PRF, Password, Salt, c, dkLen)          
        ```
        * where:
            * PRF is a pseudorandom function of two parameters with output length hLen (e.g., a keyed HMAC)
                * **MUST** store salt along with user details.
                * Alorighms like **argon2** can store along with hash itself.
            * Password is the master password from which a derived key is generated
            * Salt is a sequence of bits, known as a cryptographic salt
            * c is the number of iterations desired
            * dkLen is the desired bit-length of the derived key
            * DK is the generated derived key
        * The Open Web Application Security Project **OWASP**
            * https://www.owasp.org/index.php/Main_Page
            * https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html
            * Check adaptive one-way function section - Lists  recommendation for password storage - Updates regularly
            * Argon2 is winner of latest competition
        * **Argon2** - https://github.com/ranisalt/node-argon2
            * salt is autogenerated per user/hash and stored along with hash.
            * Generates sufficiently random salt
    * Have a password policy
        * Password validator: https://github.com/tarunbatra/password-validator
        



#### Expected Key characteristics
##### Pre-image resistance: 
Given a hash value h it should be difficult to find any message m such that h = hash(m)
##### Second pre-image resistance
Given an input m1, it should be difficult to find a different input m2 such that hash(m1) = hash(m2)
##### Collision resistance
It should be difficult to find two different messages m1 and m2 such that hash(m1) = hash(m2). Such a pair is called a cryptographic hash collision

#### Applications
* Verifying the integrity of messages and files
* Signature generation and verification
* Password verification
* File or data identifier (Git commit hash)
* ...
#### Implementations
* MD5
* sha1 ... sha3
* bcrypt ...
* ... @ https://en.wikipedia.org/wiki/Cryptographic_hash_function